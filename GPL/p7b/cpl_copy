%{
#undef __GNUC_MINOR__
#include <algorithm>
#include <iostream>
#include <sstream>
#include <cmath>
#include <stack>
#include "gpl_assert.h"
#include "symbol_table.h"
#include "symbol.h"
#include "expression.h"
#include "variable.h"
#include "event_manager.h"
#include "statement_block.h"
#include "animation_block.h"
#include "game_object.h"
#include "triangle.h"
#include "pixmap.h"
#include "circle.h"
#include "rectangle.h"
#include "textbox.h"
#include "window.h"
#include "if_statement.h"
#include "for_statement.h"
#include "print_statement.h"
#include "exit_statement.h"
#include "assign_statement.h"
#include "error.h"
#include "gpl_type.h"

using namespace std;

extern int yylex();
extern int yyerror(const char *);
extern int line_count;

int undeclared = 0;
Symbol_table* table = Symbol_table::instance();
static Event_manager *manager = Event_manager::instance();
std::stack<Statement_block *> statement_block_stack;
std::vector<Animation_block*> animation_blocks; 
Game_object *cur_object_under_construction = nullptr;
std::string cur_object_under_construction_name;
std::string cur_object_under_construction_type;

%}
%union {
    int              union_int;
    double           union_double;
    std::string      *union_string;  
    Expression       *union_expression;
    Variable         *union_variable;
    Gpl_type         gpl_type;
    int              math_operator_type;
    Symbol           *symbol; 
    Statement_block  *union_statement_block;
}
%error-verbose

%token T_INT                 "int"
%token T_DOUBLE              "double"
%token T_STRING              "string"
%token T_TRIANGLE            "triangle"
%token T_PIXMAP              "pixmap"
%token T_CIRCLE              "circle"
%token T_RECTANGLE           "rectangle"
%token T_TEXTBOX             "textbox"
%token <union_int> T_FORWARD "forward" 
%token T_INITIALIZATION      "initialization" 
%token T_TERMINATION         "termination" 
%token T_TRUE                "true"
%token T_FALSE               "false"
%token T_ON                  "on"
%token T_SPACE               "space"
%token T_LEFTARROW           "leftarrow"
%token T_RIGHTARROW          "rightarrow"
%token T_UPARROW             "uparrow"
%token T_DOWNARROW           "downarrow"
%token T_LEFTMOUSE_DOWN      "leftmouse_down"
%token T_MIDDLEMOUSE_DOWN    "middlemouse_down"
%token T_RIGHTMOUSE_DOWN     "rightmouse_down"
%token T_LEFTMOUSE_UP        "leftmouse_up"
%token T_MIDDLEMOUSE_UP      "middlemouse_up"
%token T_RIGHTMOUSE_UP       "rightmouse_up"
%token T_MOUSE_MOVE          "mouse_move"
%token T_MOUSE_DRAG          "mouse_drag"
%token T_F1                  "f1"
%token T_AKEY                "akey"
%token T_SKEY                "skey"
%token T_DKEY                "dkey"
%token T_FKEY                "fkey"
%token T_HKEY                "hkey"
%token T_JKEY                "jkey"
%token T_KKEY                "kkey"
%token T_LKEY                "lkey"
%token T_WKEY                "wkey"
%token T_ZKEY                "zkey"
%token T_TOUCHES             "touches"
%token T_NEAR                "near"
%token T_ANIMATION           "animation"
%token T_IF                  "if"
%token T_FOR                 "for"
%token T_ELSE                "else"
%token <union_int> T_PRINT   "print"
%token <union_int> T_EXIT    "exit" 
%token T_LPAREN              "("
%token T_RPAREN              ")"
%token T_LBRACE              "{"
%token T_RBRACE              "}"
%token T_LBRACKET            "["
%token T_RBRACKET            "]"
%token T_SEMIC               ";"
%token T_COMMA               ","
%token T_PERIOD              "."
%token T_ASSIGN              "="
%token T_PLUS_ASSIGN         "+="
%token T_MINUS_ASSIGN        "-="
%token T_PLUS_PLUS           "++"
%token T_MINUS_MINUS         "--"
%token T_MULTIPLY            "*"
%token T_DIVIDE              "/"
%token T_MOD                 "%"
%token T_PLUS                "+"
%token T_MINUS               "-"
%token T_SIN                 "sin"
%token T_COS                 "cos"
%token T_TAN                 "tan"
%token T_ASIN                "asin"
%token T_ACOS                "acos"
%token T_ATAN                "atan"
%token T_SQRT                "sqrt"
%token T_FLOOR               "floor"
%token T_ABS                 "abs"
%token T_RANDOM              "random"
%token T_LESS                "<"
%token T_GREATER             ">"
%token T_LESS_EQUAL          "<="
%token T_GREATER_EQUAL       ">="
%token T_EQUAL               "=="
%token T_NOT_EQUAL           "!="
%token T_AND                 "&&"
%token T_OR                  "||"
%token T_NOT                 "!"
%token <union_string> T_ID              "identifier"
%token <union_int> T_INT_CONSTANT       "int constant"
%token <union_double> T_DOUBLE_CONSTANT "double constant"
%token <union_string> T_STRING_CONSTANT "string constant"
%token T_ERROR               "error"

%nonassoc IF_NO_ELSE
%nonassoc T_ELSE

%left T_NEAR T_TOUCHES
%left T_OR 
%left T_AND
%left T_EQUAL T_NOT_EQUAL
%left T_LESS T_GREATER T_LESS_EQUAL T_GREATER_EQUAL 
%left T_PLUS T_MINUS
%left T_MULTIPLY T_DIVIDE T_MOD
%nonassoc UNARY_OPS

%type <gpl_type> simple_type
%type <gpl_type> object_type
%type <math_operator_type> math_operator
%type <union_int> keystroke
%type <union_expression> expression
%type <union_expression> primary_expression
%type <union_expression> optional_initializer
%type <union_variable> variable
%type <union_variable> variable_declaration
%type <union_statement_block> if_block
%type <union_statement_block> statement_block
%type <union_statement_block> statement_block_creator
%type <union_statement_block> assign_statement_or_empty
%type <union_statement_block> for_statement
%type <union_statement_block> assign_statement
%type <union_statement_block> animation_block
%type <symbol> animation_parameter
%type <symbol> forward_declaration
%type <symbol> check_animation_parameter

%%
//---------------------------------------------------------------------
program:
    declaration_list block_list
    {
    #if defined P7B
        if (!Error::num_errors()) {
            for (unsigned int i = 0; i < animation_blocks.size(); i++) {
                if (animation_blocks[i]->is_complete() == false) {
                    Error::error(Error::NO_BODY_PROVIDED_FOR_FORWARD, animation_blocks[i]->name());
                }
            }
        }
    #endif
    }
    ;
//---------------------------------------------------------------------
declaration_list:
    declaration_list declaration T_SEMIC | empty
    ;
//---------------------------------------------------------------------
declaration:
    variable_declaration | object_declaration | forward_declaration
    ;
//---------------------------------------------------------------------
variable_declaration:
    simple_type  T_ID  optional_initializer {
        string *name = $2;
        if ($1 == INT){
            int initial_value = 0;
            if ($3 != NULL)
            {
                if ($3->get_type() != INT && $3->get_type() != INT_ARRAY) {
                    Error::error(Error::INVALID_TYPE_FOR_INITIAL_VALUE,gpl_type_to_string($3->get_type()),*name,"int");
                }
                else {
                    if ($3->get_type() == INT) {
                        initial_value = $3->eval_int();
                    }
                }
            }
            Symbol *s = new Symbol(*name, initial_value);
            bool valid = table->insert(s);
            if (!valid) {
                Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *name);
            }
        } else if ($1 == DOUBLE){
            double initial_value = 0.0;
            if ($3 != NULL)
            {
                if (($3->get_type() != DOUBLE) && ($3->get_type() != INT)) {
                    if ($3->get_type() == INT_ARRAY || $3->get_type() == DOUBLE_ARRAY){
                    } else{
                        Error::error(Error::INVALID_TYPE_FOR_INITIAL_VALUE, "string", *name, "double");
                    }
                }
                else initial_value = $3->eval_double();
            }
            Symbol *s = new Symbol(*name, initial_value);
            bool valid = table->insert(s);
            if (!valid) {
                Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *name);
            }
        } else {
            string initial_value = "";
            if ($3 != NULL)
            {
                if ($3->get_type() == INT || $3->get_type() == DOUBLE || $3->get_type() == STRING) {
                    initial_value = $3->eval_string();
                } else if ($3->get_type() == INT_ARRAY) {
                    Variable *v = $3->eval_variable();
                    int val = v->get_int_value();
                    initial_value = to_string(val);
                } else if ($3->get_type() == DOUBLE_ARRAY) {
                    Variable *v = $3->eval_variable();
                    double val = v->get_double_value();
                    initial_value = to_string(val);
                } else if ($3->get_type() == STRING_ARRAY) {
                    Variable *v = $3->eval_variable();
                    initial_value = v->get_string_value();
                } else {
                    Error::error(Error::INVALID_TYPE_FOR_INITIAL_VALUE,gpl_type_to_string($3->get_type()), *name, "string");
                }
            }
            Symbol *s = new Symbol(*name, initial_value);
            bool valid = table->insert(s);
            if (!valid) {
                Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *name);
            }
        }
    }
    | simple_type  T_ID  T_LBRACKET expression T_RBRACKET {
        string *name = $2;
        if ($4 == NULL) {

        } else if ($4->get_type() != INT) {
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER,gpl_type_to_string($4->get_type()),*name);
        } else {
            int size = $4->eval_int();
            if (size <= 0){
                Error::error(Error::INVALID_ARRAY_SIZE, *name, to_string(size));
            } else {
                if ($1 == INT){
                    Symbol *s = new Symbol(*name, INT_ARRAY, size);
                    bool valid = table->insert(s);
                    if (!valid) {
                        Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *name);
                    }
                } else if ($1 == DOUBLE){
                    Symbol *s = new Symbol(*name, DOUBLE_ARRAY, size);
                    bool valid = table->insert(s);
                    if (!valid) {
                        Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *name);
                    }
                } else {
                    Symbol *s = new Symbol(*name, STRING_ARRAY, size);
                    bool valid = table->insert(s);
                    if (!valid) {
                        Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *name);
                    }
                }
            }
        }
    }
    ;
//---------------------------------------------------------------------
simple_type:
    T_INT { $$ = static_cast<Gpl_type>(INT); } | T_DOUBLE { $$ = static_cast<Gpl_type>(DOUBLE); } | T_STRING { $$ = static_cast<Gpl_type>(STRING); }
    ;
//---------------------------------------------------------------------
optional_initializer:
    T_ASSIGN expression { $$ = $2; } | empty { $$ = nullptr; }
//---------------------------------------------------------------------
object_declaration:
    object_type T_ID 
    {
        Symbol *symbol = new Symbol(*$2, $1);
        if (!table->insert(symbol)) {
            Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *$2);
        }
        cur_object_under_construction = symbol->get_game_object_value();
        cur_object_under_construction_name = *$2;
        cur_object_under_construction_type = gpl_type_to_string($1); 
    }
    T_LPAREN parameter_list_or_empty T_RPAREN
    {
        cur_object_under_construction = nullptr;
        cur_object_under_construction_name.clear();
    }
    | object_type T_ID T_LBRACKET expression T_RBRACKET
    {
        std::string array_name = *$2;
        Gpl_type obj_type = $1;
        Expression* size_expr = $4;
        if (size_expr == nullptr) {
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, "null", array_name);
        } else if (size_expr->get_type() != INT) {
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, gpl_type_to_string(size_expr->get_type()), array_name);
        } else {
            int array_size = size_expr->eval_int();
            if (array_size < 1) {
                Error::error(Error::INVALID_ARRAY_SIZE, array_name, std::to_string(array_size));
            } else {
                Symbol *symbol = new Symbol(array_name, static_cast<Gpl_type>(obj_type | ARRAY), array_size);
                if (!table->insert(symbol)) {
                    Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, array_name);
                }
            }
        }
    }
    ;
//---------------------------------------------------------------------
object_type:
    T_TRIANGLE   { $$ = TRIANGLE; }
    | T_PIXMAP    { $$ = PIXMAP; }
    | T_CIRCLE    { $$ = CIRCLE; }
    | T_RECTANGLE { $$ = RECTANGLE; }
    | T_TEXTBOX   { $$ = TEXTBOX; }
    ;
//---------------------------------------------------------------------
parameter_list_or_empty :
    parameter_list | empty
    ;
//---------------------------------------------------------------------
parameter_list :
    parameter_list T_COMMA parameter | parameter
    ;
//---------------------------------------------------------------------
parameter:
    T_ID T_ASSIGN expression
    {
        std::string parameter_name = *$1;
        Expression* value_expression = $3;
        Gpl_type parameter_type;
        Status status = cur_object_under_construction->get_member_variable_type(parameter_name, parameter_type);
        if (status == MEMBER_NOT_OF_GIVEN_TYPE) {
            Error::error(Error::UNKNOWN_CONSTRUCTOR_PARAMETER, cur_object_under_construction_type, parameter_name);
        } else {
            Gpl_type value_type = value_expression->get_type();
            if (value_type == ANIMATION_BLOCK) {
                Animation_block* anim = value_expression->eval_animation_block();
                if (anim && anim->get_parameter_symbol()) {
                    Gpl_type param_type = anim->get_parameter_symbol()->get_type();
                    if (param_type != cur_object_under_construction->get_type()) {
                        Error::error(Error::TYPE_MISMATCH_BETWEEN_ANIMATION_BLOCK_AND_OBJECT, cur_object_under_construction_name, anim->name());
                    }  else { cur_object_under_construction->set_member_variable(parameter_name, anim);}
                }
            } else {
            if (parameter_type != value_type && !(parameter_type == DOUBLE && value_type == INT)) {
                if(parameter_type == NO_TYPE) {
                    Error::error(Error::UNKNOWN_CONSTRUCTOR_PARAMETER, cur_object_under_construction_type, parameter_name);
                } else if (parameter_type == STRING && (value_type == INT || value_type == DOUBLE)) {
                    if(value_type == INT) {
                        cur_object_under_construction->set_member_variable(parameter_name, std::to_string(value_expression->eval_int()));
                    } else { cur_object_under_construction->set_member_variable(parameter_name, std::to_string(value_expression->eval_double()));}
                } 
                else {
                    Error::error(Error::INCORRECT_CONSTRUCTOR_PARAMETER_TYPE, cur_object_under_construction_name, parameter_name, gpl_type_to_string(value_type));
                }
            }
            else {
                if (parameter_type == ANIMATION_BLOCK) {
                    Animation_block *animation_block = value_expression->eval_animation_block();
                    cur_object_under_construction->set_member_variable(parameter_name, animation_block);
                } else if (parameter_type == INT) {
                    cur_object_under_construction->set_member_variable(parameter_name, value_expression->eval_int());
                } else if (parameter_type == DOUBLE) {
                    cur_object_under_construction->set_member_variable(parameter_name, value_expression->eval_double());
                } else if (parameter_type == STRING) {
                    cur_object_under_construction->set_member_variable(parameter_name, value_expression->eval_string());
                }
            }
            }
        }
    }
    ;
//---------------------------------------------------------------------
forward_declaration:
     T_FORWARD T_ANIMATION T_ID T_LPAREN object_type T_ID T_RPAREN 
    {
        if (table->lookup(*$6) != NULL) {
            Error::error(Error::ANIMATION_PARAMETER_NAME_NOT_UNIQUE,*$6);
        }

            // put animation block and game object into symbol table
            Symbol *s_object = new Symbol(*$6, $5);
            Symbol *s_ablock = new Symbol(*$3,ANIMATION_BLOCK);

            Animation_block *a = s_ablock->get_animation_block_value();
            a->initialize(s_object, *$3);

            table->insert(s_object);
            bool flag = table->insert(s_ablock);
            if (!flag) {
                Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *$3);
            }

            animation_blocks.push_back(a);
        
    }
    ;
//---------------------------------------------------------------------
block_list:
    block_list block | empty
    ;
//---------------------------------------------------------------------
block:
    initialization_block | termination_block | animation_block | on_block
    ;
//---------------------------------------------------------------------
initialization_block:
    T_INITIALIZATION statement_block { manager->register_handler(Window::INITIALIZE, $2);}
    ;
//---------------------------------------------------------------------
termination_block:
    T_TERMINATION statement_block { manager->register_handler(Window::TERMINATE, $2);}
    ;
//---------------------------------------------------------------------
animation_block:
    T_ANIMATION T_ID T_LPAREN check_animation_parameter 
    {
        bool error_recovery = false;
        Symbol *symbol = table->lookup(*$2);
        Animation_block *animation_block = NULL;
        if (!symbol || !symbol->is_animation_block()) {
            Error::error(Error::NO_FORWARD_FOR_ANIMATION_BLOCK, *$2);
            animation_block = new Animation_block();
            animation_block->initialize(NULL, "error_recovery");
            error_recovery = true;
        } else {
            animation_block = symbol->get_animation_block_value();
            if (animation_block->is_complete()) {
                    Error::error(Error::PREVIOUSLY_DEFINED_ANIMATION_BLOCK, *$2);
            }
            auto it = std::find(animation_blocks.begin(), animation_blocks.end(), animation_block);
            if (it != animation_blocks.end()) {
                    animation_blocks.erase(it);
            }
        }
        if (!error_recovery && $4 != animation_block->get_parameter_symbol()) {
            Error::error(Error::ANIMATION_PARAM_DOES_NOT_MATCH_FORWARD);
        }
        animation_block->mark_complete();
        statement_block_stack.push(animation_block);
        $<union_statement_block>$ = animation_block;
    }
    T_RPAREN T_LBRACE statement_list T_RBRACE end_of_statement_block { $$ = $<union_statement_block>5; }
  ;
//---------------------------------------------------------------------
animation_parameter:
    object_type T_ID
    {
        Symbol *param_symbol = new Symbol(*$2, $1);
        Game_object* param_object = param_symbol->get_game_object_value();
        if (param_object) {
            param_object->never_draw();
            param_object->never_animate();
        }
        if (!table->insert(param_symbol)) {
            Error::error(Error::ANIMATION_PARAMETER_NAME_NOT_UNIQUE, *$2);
            $$ = nullptr;
        } else { $$ = param_symbol; }
    }
    ;
//---------------------------------------------------------------------
check_animation_parameter:
    object_type T_ID
    {
        Gpl_type obj_type = $1;
        string id = *$2;
        Game_object *parameter = NULL;
        Symbol *symbol = table->lookup(id);
        if (symbol && symbol->is_game_object()) {
            parameter = symbol->get_game_object_value();
        }
        if (!symbol || !parameter || parameter->get_type() != obj_type) {
            $$ = NULL;
        } 
        else { $$ = symbol;}
    }
    ;
//---------------------------------------------------------------------
on_block:
    T_ON keystroke statement_block { manager->register_handler(static_cast<Window::Keystroke>($2), $3); }
    ;
//---------------------------------------------------------------------
keystroke:
    T_SPACE { $$ = Window::SPACE; }
    | 
    T_LEFTARROW { $$ = Window::LEFTARROW; }
    | 
    T_RIGHTARROW { $$ = Window::RIGHTARROW; }
    | 
    T_UPARROW { $$ = Window::UPARROW; }
    | 
    T_DOWNARROW { $$ = Window::DOWNARROW; }
    | 
    T_LEFTMOUSE_DOWN { $$ = Window::LEFTMOUSE_DOWN; }
    | 
    T_MIDDLEMOUSE_DOWN { $$ = Window::MIDDLEMOUSE_DOWN; }
    | 
    T_RIGHTMOUSE_DOWN { $$ = Window::RIGHTMOUSE_DOWN; }
    | 
    T_LEFTMOUSE_UP { $$ = Window::LEFTMOUSE_UP; }
    | 
    T_MIDDLEMOUSE_UP { $$ = Window::MIDDLEMOUSE_UP; }
    | 
    T_RIGHTMOUSE_UP { $$ = Window::RIGHTMOUSE_UP; }
    | 
    T_MOUSE_MOVE { $$ = Window::MOUSE_MOVE; }
    | 
    T_MOUSE_DRAG { $$ = Window::MOUSE_DRAG; }
    | 
    T_F1 { $$ = Window::F1; }
    | 
    T_AKEY { $$ = Window::AKEY; }
    | 
    T_SKEY { $$ = Window::SKEY; }
    | 
    T_DKEY { $$ = Window::DKEY; }
    | 
    T_FKEY { $$ = Window::FKEY; }
    | 
    T_HKEY { $$ = Window::HKEY; }
    | 
    T_JKEY { $$ = Window::JKEY; }
    | 
    T_KKEY { $$ = Window::KKEY; }
    | 
    T_LKEY { $$ = Window::LKEY; }
    | 
    T_WKEY { $$ = Window::WKEY; }
    | 
    T_ZKEY { $$ = Window::ZKEY; }
    ;
//---------------------------------------------------------------------
if_block:
    statement_block_creator statement end_of_statement_block { $$ = $1; } | statement_block { $$ = $1; }
    ;
//---------------------------------------------------------------------
statement_block:
    T_LBRACE statement_block_creator statement_list T_RBRACE end_of_statement_block { $$ = $2; }
    ;
//---------------------------------------------------------------------
statement_block_creator:
    {
      Statement_block *new_block = new Statement_block();
      statement_block_stack.push(new_block);
      $$ = new_block;
    }
    ;
//---------------------------------------------------------------------
end_of_statement_block:
    {
      assert(!statement_block_stack.empty());
      statement_block_stack.pop();
    }
    ;
//---------------------------------------------------------------------
statement_list:
    statement_list statement | empty
    ;
//---------------------------------------------------------------------
statement:
    if_statement | for_statement | assign_statement T_SEMIC | print_statement T_SEMIC | exit_statement T_SEMIC
    ;
//---------------------------------------------------------------------
if_statement:
    T_IF T_LPAREN expression T_RPAREN if_block %prec IF_NO_ELSE
    {
        Expression *expr = $3;
        if (expr->get_type() != INT) {
            Error::error(Error::INVALID_TYPE_FOR_IF_STMT_EXPRESSION);
            expr = new Expression(0);
        }
        statement_block_stack.top()->insert(new If_statement(expr, $5));
    }
    | T_IF T_LPAREN expression T_RPAREN if_block T_ELSE if_block
    {
        Expression *expr = $3;
        if (expr->get_type() != INT) {
            Error::error(Error::INVALID_TYPE_FOR_IF_STMT_EXPRESSION);
            expr = new Expression(0);
        }
        statement_block_stack.top()->insert(new If_statement(expr, $5, $7));
    }
    ;
//---------------------------------------------------------------------
for_statement:
    T_FOR T_LPAREN
        statement_block_creator assign_statement_or_empty end_of_statement_block T_SEMIC expression T_SEMIC
        statement_block_creator assign_statement_or_empty end_of_statement_block T_RPAREN statement_block
    {
        Expression *expr = $7; 
        if (expr->get_type() != INT) {
            Error::error(Error::INVALID_TYPE_FOR_FOR_STMT_EXPRESSION);
            expr = new Expression(0);
        }
        statement_block_stack.top()->insert(new For_statement($3, expr, $9, $13));
    }
    ;
//---------------------------------------------------------------------
print_statement:
    T_PRINT T_LPAREN expression T_RPAREN
    {
        Expression *expr = $3;
        if (expr->get_type() != INT && expr->get_type() != DOUBLE && expr->get_type() != STRING) {
            Error::error(Error::INVALID_TYPE_FOR_PRINT_STMT_EXPRESSION);
            expr = new Expression(0);
        }
        statement_block_stack.top()->insert(new Print_statement(expr, $1));
    }
    ;
//---------------------------------------------------------------------
exit_statement:
    T_EXIT T_LPAREN expression T_RPAREN
    {
        Expression *expr = $3;
        if (expr->get_type() != INT) {
            Error::error(Error::EXIT_STATUS_MUST_BE_AN_INTEGER, gpl_type_to_string(expr->get_type()));
            expr = new Expression(0);
        }
        statement_block_stack.top()->insert(new Exit_statement(expr, $1));
    }
    ;
//---------------------------------------------------------------------
assign_statement_or_empty:
    assign_statement { $$ = $1; } | empty { $$ = nullptr; }
    ;
//---------------------------------------------------------------------
assign_statement:
  variable T_ASSIGN expression
  {
      Variable *lhs = $1;
      Expression *rhs = $3;
     
      Gpl_type lhs_type = lhs->get_type();
      Gpl_type rhs_type = rhs->get_type();

      // game_object is illegal on lhs of assignment
      if (lhs_type & GAME_OBJECT)
      {
        Error::error(Error::INVALID_LHS_OF_ASSIGNMENT,
              lhs->get_name(),
              gpl_type_to_string(lhs_type)
              );
      }

      // if variable is an INT, expression must be INT
      // if variable is a DOUBLE, expression must be INT or DOUBLE
      // if variable is a STRING, expression must be STRING,INT, or DOUBLE
      // if variable is a ANIMATION_BLOCK, expression ANIMATION_BLOCK
      else if ((lhs_type == INT && rhs_type != INT)
          ||(lhs_type==DOUBLE&&(rhs_type != INT && rhs_type!=DOUBLE))
          ||(lhs_type == STRING && rhs_type == ANIMATION_BLOCK)
          ||(lhs_type==ANIMATION_BLOCK&& rhs_type != ANIMATION_BLOCK)
          )
      {
        Error::error(Error::ASSIGNMENT_TYPE_ERROR,
                     gpl_type_to_string(lhs_type),
                     gpl_type_to_string(rhs_type)
                    );
      }
        else if (lhs_type==ANIMATION_BLOCK)
        {
          // since lhs is an ANIMATION_BLOCK, it SHOULD take one of these forms
          // circle.animation_block =
          // circles[index].animation_block =

          // this is ok
          //   my_rect.animation_block = bounce;
          // this is NOT ok
          //   bounce = move;
          // check to make sure it is not this illegal form
          if (lhs->is_non_member_animation_block())
          {
            Error::error(Error::CANNOT_ASSIGN_TO_NON_MEMBER_ANIMATION_BLOCK,
                         lhs->get_name()
                        );
          }
          else
          {
  
            // get the type of the Game_object on the LHS
            Gpl_type lhs_base_object_type = lhs->get_base_game_object_type();
  
            Gpl_type rhs_param_type = rhs->eval_animation_block()->get_parameter_symbol()->get_type();
  
            // Animation_block *ablock = rhs->eval_animation_block();
            // Symbol *sym = ablock->get_parameter_symbol();
  
            if (lhs_base_object_type != rhs_param_type)
            {
              Error::error(Error::ANIMATION_BLOCK_ASSIGNMENT_PARAMETER_TYPE_ERROR,
                           gpl_type_to_string(lhs_base_object_type),
                           gpl_type_to_string(rhs_param_type)
                          );
  
            }
            else statement_block_stack.top()->insert(new Assign_statement(ASSIGN, lhs, rhs));
            }
          }
      else // the types are ok
      {
        statement_block_stack.top()->insert(new Assign_statement(ASSIGN, lhs, rhs));
      }
  }
  | variable T_PLUS_ASSIGN expression
  {
      Variable *lhs = $1;
      Expression *rhs = $3;
     
      Gpl_type lhs_type = lhs->get_type();
      Gpl_type rhs_type = rhs->get_type();

      // game_object is illegal on lhs of assignment
      if (lhs_type & GAME_OBJECT)
      {
        Error::error(Error::INVALID_LHS_OF_PLUS_ASSIGNMENT,
              lhs->get_name(),
              gpl_type_to_string(lhs_type)
              );
      }

      // if variable is an INT, expression must be INT
      // if variable is a DOUBLE, expression must be INT or DOUBLE
      // if variable is a STRING, expression must be STRING,INT, or DOUBLE
      // if variable is a ANIMATION_BLOCK, expression ANIMATION_BLOCK
      else if ((lhs_type == INT && rhs_type != INT)
          ||(lhs_type==DOUBLE&&(rhs_type != INT && rhs_type!=DOUBLE))
          ||(lhs_type == STRING && rhs_type == ANIMATION_BLOCK)
          ||(lhs_type==ANIMATION_BLOCK&& rhs_type != ANIMATION_BLOCK)
          )
      {
        Error::error(Error::PLUS_ASSIGNMENT_TYPE_ERROR,
                     gpl_type_to_string(lhs_type),
                     gpl_type_to_string(rhs_type)
                    );
      }
        else if (lhs_type==ANIMATION_BLOCK)
        {
          // since lhs is an ANIMATION_BLOCK, it SHOULD take one of these forms
          // circle.animation_block =
          // circles[index].animation_block =

          // this is ok
          //   my_rect.animation_block = bounce;
          // this is NOT ok
          //   bounce = move;
          // check to make sure it is not this illegal form
          if (lhs->is_non_member_animation_block())
          {
            Error::error(Error::CANNOT_ASSIGN_TO_NON_MEMBER_ANIMATION_BLOCK,
                         lhs->get_name()
                        );
          }
          else
          {
  
            // get the type of the Game_object on the LHS
            Gpl_type lhs_base_object_type = lhs->get_base_game_object_type();
  
            Gpl_type rhs_param_type = rhs->eval_animation_block()->get_parameter_symbol()->get_type();
  
            // Animation_block *block = rhs->eval_animation_block();
            // Symbol *sym = block->get_parameter_symbol();
  
            if (lhs_base_object_type != rhs_param_type)
            {
              Error::error(Error::ANIMATION_BLOCK_ASSIGNMENT_PARAMETER_TYPE_ERROR,
                           gpl_type_to_string(lhs_base_object_type),
                           gpl_type_to_string(rhs_param_type)
                          );
  
            }
            else statement_block_stack.top()->insert(new Assign_statement(PLUS_ASSIGN, lhs, rhs));
            }
          }
      else // the types are ok
      {
        statement_block_stack.top()->insert(new Assign_statement(PLUS_ASSIGN, lhs, rhs));
      }
  }
  | variable T_MINUS_ASSIGN expression
  {
      Variable *lhs = $1;
      Expression *rhs = $3;
     
      Gpl_type lhs_type = lhs->get_type();
      Gpl_type rhs_type = rhs->get_type();

      // game_object is illegal on lhs of assignment
      if (lhs_type & GAME_OBJECT || lhs_type & STRING)
      {
        Error::error(Error::INVALID_LHS_OF_MINUS_ASSIGNMENT,
              lhs->get_name(),
              gpl_type_to_string(lhs_type)
              );
      }

      // if variable is an INT, expression must be INT
      // if variable is a DOUBLE, expression must be INT or DOUBLE
      // if variable is a STRING, expression must be STRING,INT, or DOUBLE
      // if variable is a ANIMATION_BLOCK, expression ANIMATION_BLOCK
      else if ((lhs_type == INT && rhs_type != INT)
          ||(lhs_type==DOUBLE&&(rhs_type != INT && rhs_type!=DOUBLE))
          ||(lhs_type == STRING && rhs_type == ANIMATION_BLOCK)
          ||(lhs_type==ANIMATION_BLOCK&& rhs_type != ANIMATION_BLOCK)
          )
      {
        Error::error(Error::MINUS_ASSIGNMENT_TYPE_ERROR,
                     gpl_type_to_string(lhs_type),
                     gpl_type_to_string(rhs_type)
                    );
      }
        else if (lhs_type==ANIMATION_BLOCK)
        {
          // since lhs is an ANIMATION_BLOCK, it SHOULD take one of these forms
          // circle.animation_block =
          // circles[index].animation_block =

          // this is ok
          //   my_rect.animation_block = bounce;
          // this is NOT ok
          //   bounce = move;
          // check to make sure it is not this illegal form
          if (lhs->is_non_member_animation_block())
          {
            Error::error(Error::CANNOT_ASSIGN_TO_NON_MEMBER_ANIMATION_BLOCK,
                         lhs->get_name()
                        );
          }
          else
          {
  
            // get the type of the Game_object on the LHS
            Gpl_type lhs_base_object_type = lhs->get_base_game_object_type();
  
            Gpl_type rhs_param_type = rhs->eval_animation_block()->get_parameter_symbol()->get_type();
  
            // Animation_block *block = rhs->eval_animation_block();
            // Symbol *sym = block->get_parameter_symbol();
  
            if (lhs_base_object_type != rhs_param_type)
            {
              Error::error(Error::ANIMATION_BLOCK_ASSIGNMENT_PARAMETER_TYPE_ERROR,
                           gpl_type_to_string(lhs_base_object_type),
                           gpl_type_to_string(rhs_param_type)
                          );
  
            }
            else statement_block_stack.top()->insert(new Assign_statement(MINUS_ASSIGN, lhs, rhs));
            }
          }
      else // the types are ok
      {
        statement_block_stack.top()->insert(new Assign_statement(MINUS_ASSIGN, lhs, rhs));
      }
  }
  | variable T_PLUS_PLUS
  {
      Gpl_type lhs_type = $1->get_type();
      if (lhs_type != INT)
      {
        Error::error(Error::INVALID_LHS_OF_PLUS_PLUS,
                  $1->get_name(),
                  gpl_type_to_string(lhs_type)
                 );
      }
      else // the types are ok
      {
        statement_block_stack.top()->insert(new Assign_statement(PLUS_PLUS, $1));
      }
  }
  | variable T_MINUS_MINUS
  {
      Gpl_type lhs_type = $1->get_type();
      if (lhs_type != INT)
      {
        Error::error(Error::INVALID_LHS_OF_MINUS_MINUS,
                  $1->get_name(),
                  gpl_type_to_string(lhs_type)
                 );
      }
      else // the types are ok
      {
        statement_block_stack.top()->insert(new Assign_statement(MINUS_MINUS, $1));
      }
  }
  ;
//-----------
variable:
    T_ID {
        string *id = $1; 
        Symbol *s = table->lookup(*id);
        if (s == NULL) {
            Error::error(Error::UNDECLARED_VARIABLE,*id);
            $$ = new Variable(new Symbol("undeclared",0));
        }
        else if (s->is_array()) {
            Error::error(Error::VARIABLE_IS_AN_ARRAY,*id);
            $$ = new Variable(new Symbol("undeclared",0));
        } else {
            $$ = new Variable(table->lookup(*id));
        }
    }
    | T_ID T_LBRACKET expression T_RBRACKET {
            string *id = $1; 
            Symbol *s = table->lookup(*id);
            Expression *e = $3;
            if (s == NULL) {
                string name = *id + "[]";
                Error::error(Error::UNDECLARED_VARIABLE,name);
                $$ = new Variable(new Symbol("undeclared",0));
            }
            else if (!s->is_array()){
                Error::error(Error::VARIABLE_NOT_AN_ARRAY,*id);
                $$ = new Variable(new Symbol("undeclared",0));
            } else if (e == NULL) {
                
            } else if (e->get_type() != INT) {
                string err = "";
                if (e->get_type() == DOUBLE) {
                    err = "A double expression";
                } else if (e->get_type() == STRING) {
                    err = "A string expression";
                } else {
                    err = "A animation_block expression";
                }
                Error::error(Error::ARRAY_INDEX_MUST_BE_AN_INTEGER,*id, err);
                $$ = new Variable(new Symbol("undeclared",0));
            } 
            // else if (!s->index_within_range(e->eval_int())) {
            //     int num = e->eval_int();
            //     string n = std::to_string(num);
            //     Error::error(Error::ARRAY_INDEX_OUT_OF_BOUNDS,*id,n);
            //     $$ = new Variable(new Symbol("undeclared",0));
            // }
            else {$$ = new Variable(s, $3);}
        }
    | T_ID T_PERIOD T_ID
    {
        Symbol *s = table->lookup(*$1);
        if (s == NULL) {
            Error::error(Error::UNDECLARED_VARIABLE, *$1);
            $$ = new Variable(new Symbol("undeclared",0));
        } else {
            if (!(s->get_type() & GAME_OBJECT)) {
                Error::error(Error::LHS_OF_PERIOD_MUST_BE_OBJECT,*$1);
                $$ = new Variable(new Symbol("undeclared",0));
            } else {
                Game_object *g = s->get_game_object_value();
                if (g == NULL) {

                } else {
                    Gpl_type *type = new Gpl_type(NO_TYPE);
                    if (!g->has_member_variable(*$3)) {
                        Error::error(Error::UNDECLARED_MEMBER,*$1,*$3);
                        $$ = new Variable(new Symbol("undeclared",0));
                    } else {
                        Game_object *g = s->get_game_object_value();
                        Gpl_type *type = new Gpl_type(NO_TYPE);
                        if (!g->has_member_variable(*$3)) {
                            
                        } else {
                            g->get_member_variable_type(*$3,*type);
                            $$ = new Variable(s, $3);
                        }
                    }
                }
            }
        }
    }
    | T_ID T_LBRACKET expression T_RBRACKET T_PERIOD T_ID {
            string *id = $1; 
            Symbol *s = table->lookup(*id);
            Expression *e = $3;
            if (s == NULL) {
                string name = *id + "[]";
                Error::error(Error::UNDECLARED_VARIABLE,name);
                $$ = new Variable(new Symbol("undeclared",0));
            }
            else if (!s->is_array()){
                Error::error(Error::VARIABLE_NOT_AN_ARRAY,*id);
                $$ = new Variable(new Symbol("undeclared",0));
            } else if (e == NULL) {
                
            } else if (e->get_type() != INT) {
                string err = "";
                if (e->get_type() == DOUBLE) {
                    err = "A double expression";
                } else if (e->get_type() == STRING) {
                    err = "A string expression";
                } else {
                    err = "A animation_block expression";
                }
                Error::error(Error::ARRAY_INDEX_MUST_BE_AN_INTEGER,*id, err);
                $$ = new Variable(new Symbol("undeclared",0));
            } else if (!s->index_within_range(e->eval_int())) {
                int num = e->eval_int();
                string n = std::to_string(num);
                Error::error(Error::ARRAY_INDEX_OUT_OF_BOUNDS,*id,n);
                $$ = new Variable(new Symbol("undeclared",0));
            }
            else if (!s->is_game_object()) {
                Error::error(Error::LHS_OF_PERIOD_MUST_BE_OBJECT,*$1);
                $$ = new Variable(new Symbol("undeclared",0));
            } else {
                int index = e->eval_int();
                Game_object *g = s->get_game_object_value(index);
                Gpl_type *type = new Gpl_type(NO_TYPE);
                if (!g->has_member_variable(*$6)) {
                    
                } else {
                    g->get_member_variable_type(*$6,*type);
                    $$ = new Variable(s, e, $6);
                }
            }
    }

    ;
//---------------------------------------------------------------------
expression:
    primary_expression {
        Expression *e = $1;
        $$ = $1;
        }
    | expression T_OR expression {
            $$ = new Expression(0);
            if ($1->get_type() == STRING){
                Error::error(Error::INVALID_LEFT_OPERAND_TYPE, "||");
            } 
            if ($3->get_type() == STRING){
                Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "||");
            } 
            if ($1->get_type() != STRING && $3->get_type() != STRING) {
                $$ = new Expression(OR, $1, $3);
            }
        }
    | expression T_AND expression {
            $$ = new Expression(0);
            if ($1->get_type() == STRING){
                Error::error(Error::INVALID_LEFT_OPERAND_TYPE, "&&");
                $$ = new Expression(0);
            } 
            if ($3->get_type() == STRING){
                Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "&&");
                $$ = new Expression(0);
            } 
            if ($1->get_type() != STRING && $3->get_type() != STRING) {
                $$ = new Expression(AND, $1, $3);
            }
        }
    | expression T_LESS_EQUAL expression {
        $$ = new Expression(LESS_EQUAL, $1, $3);
        if ($1->get_type() != INT && $1->get_type() != DOUBLE && $1->get_type()!=STRING) {
            Error::error(Error::INVALID_LEFT_OPERAND_TYPE, "<=");
            $$ = NULL;
        }
        if ($3->get_type() != INT && $3->get_type() != DOUBLE && $3->get_type()!=STRING) {
            Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "<=");
            $$ = NULL;
        }
        }
    | expression T_GREATER_EQUAL  expression {
        $$ = new Expression(GREATER_EQUAL, $1, $3);
        if ($1->get_type() != INT && $1->get_type() != DOUBLE && $1->get_type()!=STRING) {
            Error::error(Error::INVALID_LEFT_OPERAND_TYPE, ">=");
            $$ = NULL;
        }
        if ($3->get_type() != INT && $3->get_type() != DOUBLE && $3->get_type()!=STRING) {
            Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, ">=");
            $$ = NULL;
        }
        }
    | expression T_LESS expression {
        $$ = new Expression(LESS_THAN, $1, $3);
        if ($1->get_type() != INT && $1->get_type() != DOUBLE && $1->get_type()!=STRING) {
            Error::error(Error::INVALID_LEFT_OPERAND_TYPE, "<");
            $$ = NULL;
        }
        if ($3->get_type() != INT && $3->get_type() != DOUBLE && $3->get_type()!=STRING) {
            Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "<");
            $$ = NULL;
        }
        }
    | expression T_GREATER  expression {
        $$ = new Expression(GREATER_THAN, $1, $3);
        if ($1->get_type() != INT && $1->get_type() != DOUBLE && $1->get_type()!=STRING) {
            Error::error(Error::INVALID_LEFT_OPERAND_TYPE, ">");
            $$ = NULL;
        }
        if ($3->get_type() != INT && $3->get_type() != DOUBLE && $3->get_type()!=STRING) {
            Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, ">");
            $$ = NULL;
        }
        }
    | expression T_EQUAL expression {
        $$ = new Expression(EQUAL, $1, $3);
        if ($1->get_type() != INT && $1->get_type() != DOUBLE && $1->get_type()!=STRING) {
            Error::error(Error::INVALID_LEFT_OPERAND_TYPE, "==");
            $$ = NULL;
        }
        if ($3->get_type() != INT && $3->get_type() != DOUBLE && $3->get_type()!=STRING) {
            Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "==");
            $$ = NULL;
        }
        }
    | expression T_NOT_EQUAL expression {$$ = new Expression(NOT_EQUAL, $1, $3);}
    | expression T_PLUS expression {
        $$ = new Expression(PLUS, $1, $3);
        if ($1->get_type() != INT && $1->get_type() != DOUBLE && $1->get_type()!=STRING) {
            Error::error(Error::INVALID_LEFT_OPERAND_TYPE, "+");
            $$ = new Expression(0);
        }
        if ($3->get_type() != INT && $3->get_type() != DOUBLE && $3->get_type()!=STRING) {
            Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "+");
            $$ = new Expression(0);
        }
    }
    | expression T_MINUS expression {
        $$ = new Expression(MINUS, $1, $3);
        if ($1->get_type() != INT && $1->get_type() != DOUBLE){
                Error::error(Error::INVALID_LEFT_OPERAND_TYPE, "-");
                $$ = new Expression(0);
        }
        if ($3->get_type() != INT && $3->get_type() != DOUBLE){
                Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "-");
                $$ = new Expression(0);
        } 
        }
    | expression T_MULTIPLY expression {
        $$ = new Expression(MULTIPLY, $1, $3);
        if ($1->get_type() != INT && $1->get_type() != DOUBLE){
                Error::error(Error::INVALID_LEFT_OPERAND_TYPE, "*");
                $$ = new Expression(0);
        }
        if ($3->get_type() != INT && $3->get_type() != DOUBLE){
                Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "*");
                $$ = new Expression(0);
        } 
        }
    | expression T_DIVIDE expression {
            $$ = new Expression(DIVIDE, $1, $3);
            if ($1->get_type() != INT && $1->get_type() != DOUBLE){
                    Error::error(Error::INVALID_LEFT_OPERAND_TYPE, "/");
                    $$ = new Expression(0);
            }
            if ($3->get_type() != INT && $3->get_type() != DOUBLE){
                    Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "/");
                    $$ = new Expression(0);
            } 
        }
    | expression T_MOD expression {
            $$ = new Expression(MOD, $1, $3);
            if ($1->get_type() != INT){
                    Error::error(Error::INVALID_LEFT_OPERAND_TYPE, "%");
                    $$ = new Expression(0);
            }
            if ($3->get_type() != INT){
                    Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "%");
                    $$ = new Expression(0);
            } 
        }
    | T_MINUS  expression %prec UNARY_OPS {
            if ($2->get_type() != INT && $2->get_type() != DOUBLE){
                Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "-");
                $$ = new Expression(0);
            } else {
                $$ = new Expression(UNARY_MINUS, $2);
            }
        }
    | T_NOT  expression %prec UNARY_OPS {
            if ($2->get_type() != INT && $2->get_type() != DOUBLE) {
                Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "!");
                $$ = new Expression(0);
            } else {
                $$ = new Expression(NOT, $2);
            }
        }
    | math_operator T_LPAREN expression T_RPAREN {
        if ($3->get_type() == INT || $3->get_type() == DOUBLE){
            $$ = new Expression(ABS, $3);
        } else {

            Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, "todo");
            $$ = new Expression(0);
        }
        }
    | expression T_NEAR expression {
         Expression *e1 = $1;
        Expression *e2 = $3;
        if (!e1) {

        } else if (!e2) {

        }
        else if (!(e1->get_type() & GAME_OBJECT) || !(e2->get_type() & GAME_OBJECT)) {
        } else {
            // Variable *v1 = e1->eval_variable();
            // Variable *v2 = e2->eval_variable();

            // assert(v1->is_game_object());
            // assert(v2->is_game_object());

            // Game_object *g1 = v1->get_game_object_value();
            // Game_object *g2 = v2->get_game_object_value();

            $$ = new Expression(NEAR, e1, e2);
        }
    }
    | expression T_TOUCHES expression {
        Expression *e1 = $1;
        Expression *e2 = $3;
        if (!e1) {

        } else if (!e2) {

        }
        else if (!(e1->get_type() & GAME_OBJECT) || !(e2->get_type() & GAME_OBJECT)) {
        } else {
            // Variable *v1 = e1->eval_variable();
            // Variable *v2 = e2->eval_variable();

            // assert(v1->is_game_object());
            // assert(v2->is_game_object());

            // Game_object *g1 = v1->get_game_object_value();
            // Game_object *g2 = v2->get_game_object_value();

            $$ = new Expression(TOUCHES, e1, e2);
        }
    }
    ;
//---------------------------------------------------------------------
primary_expression:
    T_LPAREN expression T_RPAREN { if ($2 == nullptr) { $$ = new Expression(0); } else { $$ = $2; }}
    | variable { if ($1 == nullptr) { $$ = new Expression(0); } else { $$ = new Expression($1); }}
    | T_INT_CONSTANT { $$ = new Expression($1); }
    | T_TRUE { $$ = new Expression(1); }
    | T_FALSE { $$ = new Expression(0); }
    | T_DOUBLE_CONSTANT { $$ = new Expression($1); }
    | T_STRING_CONSTANT { $$ = new Expression($1); }
    ;
//---------------------------------------------------------------------
math_operator:
    T_SIN { $$ = SIN; }
    | T_COS { $$ = COS; }
    | T_TAN { $$ = TAN; }
    | T_ASIN { $$ = ASIN; }
    | T_ACOS { $$ = ACOS; }
    | T_ATAN { $$ = ATAN; }
    | T_SQRT { $$ = SQRT; }
    | T_FLOOR { $$ = FLOOR; }
    | T_ABS { $$ = ABS; }
    | T_RANDOM { $$ = RANDOM; }
    ;
//---------------------------------------------------------------------
empty:
    ;